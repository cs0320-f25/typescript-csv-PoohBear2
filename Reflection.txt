1. A correct CSV parser should maintain delimiter integrity. A delimiter, such as a comma, that appears inside a field enclosed in double quotes must be interpreted as part of the field’s content rather than incorrectly splitting the field. It should also ensure structural consistency. Every row in the parsed output must contain the same number of columns. If a row appears with fewer or more fields than expected, the parser should clearly report the issue instead of silently producing inconsistent data. Whitespace handling is also needed. While whitespace surrounding unquoted fields should be trimmed away, any whitespace within quoted fields must be preserved exactly as written as it could be a deliberate detail left by the user. Predictable state handling ensures the parser behaves consistently in edge cases. An empty file should always yield an empty result array, and any blank lines in the file should be ignored rather than treated as valid rows.
2. Property-based testing provides a way to define universal rules that the parser must always follow. Any dataset converted into CSV format and then parsed back should exactly match the original. Random generation helps uncover tricky edge cases that developers might not anticipate, such as fields containing unusual combinations of quotes, delimiters, or non-standard characters. Beyond correctness, fuzzing with randomly generated malformed data ensures robustness by testing that the parser never crashes or fails silently when encountering unexpected input. 
3. The assignment required empathy towards human needs. My experience with past assignments in CS has mostly been “make this work, that is it”. Now, we have to make things work while ensuring the stuff that works aligns with the actual preferences and needs of real people. I encountered a TypeScript generics error as well: the compiler rejected the type (string[ ] | T) [ ] as incompatible with the expected type T[ ] | string[ ] [ ]. The solution was to restructure the function into two separate code paths. If a schema was provided, declared and populated a T[] array. Otherwise, we have the string[][] case. 
